import type { Observable } from "torc";
import { shift, then, keep, map } from "torc";
import { pipe } from "ts-functional-pipe";
import fs from "node:fs/promises";
import { Ollama } from "ollama";
import type { ChatResponse } from "ollama";

(async function main() {
  const [host = "http://exodus:11434"] = process.argv.slice(2);
  const ollama = new Ollama({ host });
  const messages: { role: string; content: string }[] = [];
  void pipe(
    then((query: string) =>
      keep(
        (async () => {
          messages.push({ role: "user", content: query });
          await fs.appendFile("./out", `> ${query}`);
          return queryModel(ollama, "llama3.1", messages);
        })()
      )
    ),
    then(collect),
    map((lines) => lines.map((l) => l.message.content).join(""))
  )(await openInput()).subscribe((content) => {
    messages.push({ role: "assistant", content });
    fs.appendFile("./out", `< ${content}\n`);
  });
})();

/**
 * Opens the input pipe and returns an observable of the lines written to it.
 * @returns A promise of an observable of lines written to the input pipe.
 */
async function openInput(): Promise<Observable<string>> {
  const inFile = await fs.open("./in", "r+");
  return shift((k) =>
    inFile.createReadStream().on("data", (d) => k(d.toString()))
  );
}

/**
 * Queries an Ollama server and sends back an async iterable of responses.
 * @param ollama - The Ollama API client.
 * @param model - The model to use with our query.
 * @param content - The actual message we are sending the model.
 * @returns A promise of an async iterable of {@link ChatResponse} values.
 */
function queryModel(
  ollama: Ollama,
  model: string,
  messages: { role: string; content: string }[]
): Promise<AsyncIterable<ChatResponse>> {
  return ollama.chat({
    model,
    messages,
    stream: true,
  });
}

/**
 * Collects the values generated by an iterable or async iterable into a single
 * array and creates a singleton observer that publishes that array.
 * @typeParam A - The values produced by the iterable / async-iterable.
 * @param it - The iterable or async iterable whose values we will collect.
 * @returns an observable publishing an array containing all the iterated values.
 */
function collect<A>(it: Iterable<A> | AsyncIterable<A>): Observable<A[]> {
  return shift(async (k) => {
    const parts = [];
    for await (const part of it) parts.push(part);
    k(parts);
  });
}
