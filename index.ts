import type { Observable } from "torc";
import { shift, then, keep, map } from "torc";
import { pipe } from "ts-functional-pipe";
import fs from "node:fs/promises";
import { Ollama } from "ollama";
import type { ChatResponse } from "ollama";

(async function main() {
  const [host = "http://exodus:11434"] = process.argv.slice(2);
  const ollama = new Ollama({ host });
  const messages: { role: string; content: string }[] = [];
  void pipe(
    then((query: string) =>
      keep(
        (async () => {
          messages.push({ role: "user", content: query });
          await fs.appendFile("./out", `> ${query}`);
          return ollama.chat({ model: "llama3.1", messages, stream: true });
        })()
      )
    ),
    then(collect),
    map((lines) => lines.map((l) => l.message.content).join(""))
  )(await openInput()).subscribe((content) => {
    messages.push({ role: "assistant", content });
    fs.appendFile("./out", `< ${content}\n`);
  });
})();

/**
 * Opens the input pipe and returns an observable of the lines written to it.
 * @returns A promise of an observable of lines written to the input pipe.
 */
async function openInput(): Promise<Observable<string>> {
  const inFile = await fs.open("./in", "r+");
  return shift((k) =>
    inFile.createReadStream().on("data", (d) => k(d.toString()))
  );
}

/**
 * Collects the values generated by an iterable or async iterable into a single
 * array and creates a singleton observer that publishes that array.
 * @typeParam A - The values produced by the iterable / async-iterable.
 * @param it - The iterable or async iterable whose values we will collect.
 * @returns an observable publishing an array containing all the iterated values.
 */
function collect<A>(it: Iterable<A> | AsyncIterable<A>): Observable<A[]> {
  return shift(async (k) => {
    const parts = [];
    for await (const part of it) parts.push(part);
    k(parts);
  });
}
